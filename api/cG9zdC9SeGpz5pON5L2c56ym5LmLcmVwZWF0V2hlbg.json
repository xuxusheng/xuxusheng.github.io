{"title":"Rxjs操作符之repeatWhen","date":"2017-08-21T21:01:22.000Z","author":"许盛","excerpt":"","slug":"Rxjs操作符之repeatWhen","comments":true,"tags":["rxjs"],"categories":["rxjs"],"updated":"2018-08-23T09:18:11.075Z","content":"<p><strong>官网介绍如下：</strong><br><a href=\"http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-repeatWhen\" target=\"_blank\" rel=\"noopener\">http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-repeatWhen</a></p>\n<p>放珠宝图：<br><img src=\"assets/images/Rxjs操作符之repeatWhen/marble-diagrams.png\" alt=\"marble-diagrams\"></p>\n<p>简而言之，就是 <code>repeatWhen</code> 操作符接收一个函数，这个函数返回一个新的 <code>Observable</code> ，暂且称之为 <code>notifications</code>。</p>\n<p>那么当 <code>Source Observable</code> 进入 <code>complete</code> 或者 <code>error</code> 状态时，先要去看一看 <code>notifications</code> 的状态，如果 <code>notifications</code> 是 <code>complete</code> 或者 <code>error</code> 状态，那么就触发 <code>Source Observable</code> 相应的状态，否则就返回一个基于 <code>Source Observable</code> 的 <code>Mirror Observable</code>，以此往复。</p>\n<p><strong>注意：</strong></p>\n<p>这里需要注意的是，如果 <code>notifications</code> 进入 <code>complete</code> 状态，而 <code>Source Observable</code> 还未进入 complete 状态，那么会一直等待 <code>Source Observable</code> 进入 <code>complete</code> 状态后将整个流结束掉。</p>\n<blockquote>\n<p>早期版本这里有个 bug，<code>notifications</code> 进入 <code>complete</code> 之后，会直接将 <code>Source Observable</code> 也置为 <code>complete</code>。<br>参见：<a href=\"https://github.com/ReactiveX/rxjs/pull/2209\" target=\"_blank\" rel=\"noopener\">https://github.com/ReactiveX/rxjs/pull/2209</a></p>\n</blockquote>\n<p><strong>例子：</strong></p>\n<p><a href=\"https://codepen.io/xusheng/pen/KvoJop?editors=1012\" target=\"_blank\" rel=\"noopener\">https://codepen.io/xusheng/pen/KvoJop?editors=1012</a></p>\n","prev":{"title":"typescript 中通过构造函数的参数直接定义属性","slug":"typescript中通过构造函数的参数直接定义属性"},"next":{"title":"centos 下查看本机公网IP","slug":"centos下查看本机公网IP"},"link":"/post/Rxjs操作符之repeatWhen"}